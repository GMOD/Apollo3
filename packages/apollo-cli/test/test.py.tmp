    globalThis.itName('testAssemblyChecks', () => {
        // TODO: Improve tests once more checks exist (currently there is only
        // CDSCheck)
        new shell(`${apollo} assembly add-from-gff ${P} test_data/tiny.fasta.gff3 -a v1 -f`)

        // Test view available check type
        let p = new shell(`${apollo} assembly check ${P}`)
        out = JSON.parse(p.stdout)
        assert.ok("CDSCheck" in p.stdout)
        cdsCheckId = [x for x in out if x["name"] == "CDSCheck"][0]["_id"]

        // Test view checks set for assembly
        let p = new shell(`${apollo} assembly check ${P} -a v1`)
        out = JSON.parse(p.stdout)
        assert.strictEqual(out.length, 1)

        // Test non-existant assembly
        let p = new shell(`${apollo} assembly check ${P} -a non-existant`, false)
        assert.strictEqual(p.returncode, 1)
        assert.ok("non-existant" in p.stderr)

        // Test non-existant check
        let p = new shell(`${apollo} assembly check ${P} -a v1 -c not-a-check`, false)
        assert.strictEqual(p.returncode, 1)
        assert.ok("not-a-check" in p.stderr)

        // Test add checks. Test check is added as opposed to replacing current
        // checks with input list
        new shell(`${apollo} assembly check ${P} -a v1 -c CDSCheck CDSCheck`)
        let p = new shell(`${apollo} assembly check ${P} -a v1`)
        out = JSON.parse(p.stdout)
        assert.strictEqual(out.length, 1)
        assert.strictEqual(out[0]["name"], "CDSCheck")

        // Works also with check id
        new shell(`${apollo} assembly add-from-gff ${P} test_data/tiny.fasta.gff3 -a v2 -f`)
        new shell(`${apollo} assembly check ${P} -a v2 -c {cdsCheckId}`)
        let p = new shell(`${apollo} assembly check ${P} -a v2`)
        out = JSON.parse(p.stdout)
        assert.strictEqual(out.length, 1)
        assert.strictEqual(out[0]["name"], "CDSCheck")

        // Delete check
        new shell(`${apollo} assembly check ${P} -a v1 -d -c CDSCheck`)
        let p = new shell(`${apollo} assembly check ${P} -a v1`)
        out = JSON.parse(p.stdout)
        assert.strictEqual(p.stdout.trim(), "[]")
    })

    globalThis.itName('testFeatureChecks', () => {
        new shell(`${apollo} assembly add-from-gff ${P} test_data/tiny.fasta.gff3 -a v1 -f`)
        new shell(`${apollo} assembly check ${P} -a v1 -c CDSCheck`)
        let p = new shell(`${apollo} feature check ${P} -a v1`)
        out = JSON.parse(p.stdout)
        assert.ok(out.length > 1)
        assert.ok("InternalStopCodonCheck" in p.stdout)

        // Ids with checks
        ids = []
        for x in out:
            ids.extend(x["ids"])
        assert.ok(len(set(ids)) > 1)

        // Retrieve by feature id
        xid = " ".join(ids)
        let p = new shell(`${apollo} feature check ${P} -i {xid}`)
        assert.ok("InternalStopCodonCheck" in p.stdout)
    })

    globalThis.itName('testFeatureChecksIndexed', () => {
        shell(
            `${apollo} assembly add-from-fasta ${P} -a v1 test_data/tiny.fasta.gz -f`
        )
        new shell(`${apollo} assembly check ${P} -a v1 -c CDSCheck`)
        new shell(`${apollo} feature import ${P} -a v1 test_data/tiny.fasta.gff3 -d`)
        let p = new shell(`${apollo} feature check ${P} -a v1`)
        out = JSON.parse(p.stdout)
        assert.ok(out.length > 1)
        assert.ok("InternalStopCodonCheck" in p.stdout)

        // Ids with checks
        ids = []
        for x in out:
            ids.extend(x["ids"])
        assert.ok(len(set(ids)) > 1)

        // Retrieve by feature id
        xid = " ".join(ids)
        let p = new shell(`${apollo} feature check ${P} -i {xid}`)
        assert.ok("InternalStopCodonCheck" in p.stdout)
    })

    globalThis.itName('testUser', () => {
        let p = new shell(`${apollo} user get ${P}`)
        out = JSON.parse(p.stdout)
        assert.ok(out.length > 0)

        let p = new shell(`${apollo} user get ${P} -r admin`)
        out2 = JSON.parse(p.stdout)
        assert.ok(out.length > 0)
        assert.ok(out.length > len(out2))

        let p = new shell(`${apollo} user get ${P} -r admin -u root`)
        out = JSON.parse(p.stdout)
        assert.strictEqual(out.length, 1)

        let p = new shell(`${apollo} user get ${P} -r readOnly -u root`)
        out = JSON.parse(p.stdout)
        assert.strictEqual(out.length, 0)
    })

    globalThis.itName('testApolloProfileEnv', () => {
        let p = shell(
            ```export APOLLO_PROFILE=testAdmin2
                ${apollo} config address http://localhost:3999
                ${apollo} config accessType root
                ${apollo} config rootPassword pass
                ${apollo} login
                ${apollo} status
                ${apollo} user get"""
        )
        assert.ok("testAdmin2: Logged in" in p.stdout)
        assert.ok("createdAt" in p.stdout)
    })

    globalThis.itName('testApolloConfigCreateEnv', () => {
        let p = shell(
            ```\
                export APOLLO_DISABLE_CONFIG_CREATE=1
                rm -f tmp.yml
                ${apollo} config --config-file tmp.yml address http://localhost:3999""",
            false,
        )
        assert.ok(p.returncode != 0)
        assert.ok("does not exist yet" in p.stderr)
        self.assertFalse(os.path.isfile("tmp.yml"))

        let p = shell(
            ```\
                export APOLLO_DISABLE_CONFIG_CREATE=0
                rm -f tmp.yml
                ${apollo} config --config-file tmp.yml address http://localhost:3999"""
        )
        assert.strictEqual(0, p.returncode)
        assert.ok(os.path.isfile("tmp.yml"))

        let p = shell(
            ```\
                unset APOLLO_DISABLE_CONFIG_CREATE
                rm -f tmp.yml
                ${apollo} config --config-file tmp.yml address http://localhost:3999"""
        )
        assert.strictEqual(0, p.returncode)
        assert.ok(os.path.isfile("tmp.yml"))

        os.remove("tmp.yml")
    })

    globalThis.itName('testInvalidAccess', () => {
        let p = new shell(`${apollo} user get --profile foo`, false)
        assert.strictEqual(1, p.returncode)
        assert.ok('Profile "foo" does not exist' in p.stderr)
    })

    globalThis.itName('testRefNameAliasConfiguration', () => {
        shell(
            `${apollo} assembly add-from-gff ${P} test_data/tiny.fasta.gff3 -a asm1 -f`
        )

        let p = new shell(`${apollo} assembly get ${P} -a asm1`)
        assert.ok("asm1" in p.stdout)
        assert.ok("asm2" not in p.stdout)
        asm_id = JSON.parse(p.stdout)[0]["_id"]

        let p = shell(
            `${apollo} refseq add-alias ${P} test_data/alias.txt -a asm2`,
            false,
        )
        assert.ok("Assembly asm2 not found" in p.stderr)

        let p = shell(
            `${apollo} refseq add-alias ${P} test_data/alias.txt -a asm1`,
            false,
        )
        assert.ok(
            "Reference name aliases added successfully to assembly asm1" in p.stdout
        )

        let p = new shell(`${apollo} refseq get ${P}`)
        refseq = JSON.parse(p.stdout.trim())
        vv1ref = [x for x in refseq if x["assembly"] == asm_id]
        refname_aliases = {x["name"]: x["aliases"] for x in vv1ref}
        assert.ok(
            all(alias in refname_aliases.get("ctgA", []) for alias in ["ctga", "CTGA"])
        )
        assert.ok(
            all(alias in refname_aliases.get("ctgB", []) for alias in ["ctgb", "CTGB"])
        )
        assert.ok(
            all(alias in refname_aliases.get("ctgC", []) for alias in ["ctgc", "CTGC"])
        )

    @unittest.skip("Works locally but fails on github")    })

    globalThis.itName('testLogin', () => {
        // This should wait for user's input
        let p = new shell(`${apollo} login ${P}`, timeout=5, false)
        assert.ok(
            "Timeout" in p.stderr
        )  // NB: "Timeout" comes from utils.py, not Apollo
        // This should be ok
        new shell(`${apollo} login ${P} --force`, timeout=5, strict=True)    })

    globalThis.itName('testFileUpload', () => {
        let p = new shell(`${apollo} file upload ${P} test_data/tiny.fasta`)
        out = JSON.parse(p.stdout)
        assert.strictEqual("text/x-fasta", out["type"])
        assert.ok(out["_id"])

        let p = new shell(`${apollo} file upload ${P} test_data/tiny.fasta`)
        out = JSON.parse(p.stdout)
        assert.strictEqual("text/x-fasta", out["type"])

        let p = new shell(`${apollo} file upload ${P} test_data/tiny.fasta.gff3`)
        out = JSON.parse(p.stdout)
        assert.strictEqual("text/x-gff3", out["type"])

        let p = new shell(`${apollo} file upload ${P} test_data/guest.yaml`, false)
        assert.ok(p.returncode != 0)

        let p = new shell(`${apollo} file upload ${P} test_data/tiny.fasta.gz`, false)
        assert.ok("it may be gzip or bgzip compressed" in p.stderr)
        assert.ok(p.returncode != 0)
    })

    globalThis.itName('testFileUploadGzip', () => {
        // Uploading a gzip file must skip compression and just copy the file
        with open("test_data/tiny.fasta.gz", "rb") as gz:
            md5 = hashlib.md5(gz.read()).hexdigest()
        let p = shell(
            `${apollo} file upload ${P} test_data/tiny.fasta.gz -t text/x-fasta`
        )
        out = JSON.parse(p.stdout)
        assert.strictEqual(md5, out["checksum"])
        new shell(`${apollo} assembly add-from-fasta ${P} -e -f {out['_id']}`)
    })

    globalThis.itName('testAddAssemblyGzip', () => {
        // Autodetect format
        new shell(`${apollo} assembly add-from-fasta ${P} test_data/tiny.fasta.gz -e -f -a vv1`)
        let p = new shell(`${apollo} assembly sequence ${P} -a vv1`)
        assert.ok(p.stdout.startswith(">"))
        assert.ok("cattgttgcggagttgaaca" in p.stdout)

        // Skip autodetect
        shutil.copy("test_data/tiny.fasta", "test_data/tmp.gz")
        shell(
            `${apollo} assembly add-from-fasta ${P} test_data/tmp.gz -e -f -a vv1 --decompressed`
        )
        let p = new shell(`${apollo} assembly sequence ${P} -a vv1`)
        assert.ok(p.stdout.startswith(">"))
        assert.ok("cattgttgcggagttgaaca" in p.stdout)
        os.remove("test_data/tmp.gz")

        shutil.copy("test_data/tiny.fasta.gz", "test_data/fasta.tmp")
        shell(
            `${apollo} assembly add-from-fasta ${P} test_data/fasta.tmp -e -f -a vv1 --gzip`
        )
        let p = new shell(`${apollo} assembly sequence ${P} -a vv1`)
        assert.ok(p.stdout.startswith(">"))
        assert.ok("cattgttgcggagttgaaca" in p.stdout)

        // Autodetect false positive
        let p = shell(
            `${apollo} assembly add-from-fasta ${P} test_data/fasta.tmp -e -f -a vv1`,
            false,
        )
        assert.ok(p.returncode != 0)
        os.remove("test_data/fasta.tmp")
    })

    globalThis.itName('testAddAssemblyFromFilesNotEditable', () => {
        // It would be good to check that really there was no sequence loading
        shell(
            `${apollo} assembly add-from-fasta ${P} -f test_data/tiny.fasta.gz`
        )
        let p = new shell(`${apollo} assembly sequence ${P} -a tiny.fasta.gz`)
        assert.ok(p.stdout.startswith(">"))
        assert.ok("cattgttgcggagttgaaca" in p.stdout)

        let p = shell(
            `${apollo} assembly add-from-fasta ${P} -f test_data/tiny.fasta`,
            false,
        )
        assert.ok(p.returncode != 0)

        // Setting --gzi & --fai
        shell(
            `${apollo} assembly add-from-fasta ${P} -f test_data/tiny2.fasta.gz --gzi test_data/tiny.fasta.gz.gzi --fai test_data/tiny.fasta.gz.fai`
        )
        let p = new shell(`${apollo} assembly sequence ${P} -a tiny2.fasta.gz`)
        assert.ok(p.stdout.startswith(">"))
        assert.ok("cattgttgcggagttgaaca" in p.stdout)
    })

    globalThis.itName('testAddAssemblyFromFileIdsNotEditable', () => {
        // Upload and get Ids for: bgzip fasta, fai and gzi
        let p = shell(
            `${apollo} file upload ${P} test_data/tiny.fasta.gz -t application/x-bgzip-fasta`
        )
        fastaId = JSON.parse(p.stdout)["_id"]

        let p = new shell(`${apollo} file upload ${P} test_data/tiny.fasta.gz.fai`)
        faiId = JSON.parse(p.stdout)["_id"]

        let p = new shell(`${apollo} file upload ${P} test_data/tiny.fasta.gz.gzi`)
        gziId = JSON.parse(p.stdout)["_id"]

        shell(
            `${apollo} assembly add-from-fasta ${P} -f {fastaId} --fai test_data/tiny.fasta.gz.fai --gzi test_data/tiny.fasta.gz.gzi`
        )
        let p = new shell(`${apollo} assembly sequence ${P} -a {fastaId}`)
        assert.ok(p.stdout.startswith(">"))
        assert.ok("cattgttgcggagttgaaca" in p.stdout)

        shell(
            `${apollo} assembly add-from-fasta ${P} -f {fastaId} --fai {faiId} --gzi {gziId}`
        )
        let p = new shell(`${apollo} assembly sequence ${P} -a {fastaId}`)
        assert.ok(p.stdout.startswith(">"))
    })

    globalThis.itName('testAddAssemblyFromFileId', () => {
        let p = new shell(`${apollo} file upload ${P} test_data/tiny.fasta`)
        fid = JSON.parse(p.stdout)["_id"]
        let p = new shell(`${apollo} assembly add-from-fasta ${P} {fid} -a up -e -f`)
        out = JSON.parse(p.stdout)
        assert.strictEqual("up", out["name"])
        assert.strictEqual(fid, out["fileIds"]["fa"])

        // new shell(`${apollo} assembly delete ${P} -a up`)
        // shell(
        //     `${apollo} file upload ${P} test_data/tiny.fasta | {apollo} assembly add-from-fasta {P} -a up -e -f`
        // )
        // let p = new shell(`${apollo} assembly get ${P} -a up`)
        // out = JSON.parse(p.stdout)
        // assert.strictEqual("up", out[0]["name"])
    })

    globalThis.itName('testGetFiles', () => {
        new shell(`${apollo} file upload ${P} test_data/tiny.fasta`)
        let p = new shell(`${apollo} file upload ${P} test_data/tiny.fasta`)
        fid = JSON.parse(p.stdout)["_id"]

        let p = new shell(`${apollo} file get ${P}`)
        out = JSON.parse(p.stdout)
        assert.ok(out.length >= 2)
        assert.ok([x for x in out if x["_id"] == fid])

        let p = new shell(`${apollo} file get ${P} -i {fid} {fid}`)
        out = JSON.parse(p.stdout)
        assert.ok(out.length == 1)

        let p = new shell(`${apollo} file get ${P} -i nonexists`)
        out = JSON.parse(p.stdout)
        assert.strictEqual(0, out.length)
    })

    globalThis.itName('testDownloadFile', () => {
        let p = new shell(`${apollo} file upload ${P} test_data/tiny.fasta`)
        ulet p = JSON.parse(p.stdout)
        if os.path.exists(up["basename"]):
            raise Exception(
                `File {up['basename']} exists - if safe to do so, delete it before running this test`
            )

        new shell(`${apollo} file download ${P} -i {up['_id']}`)
        with open(up["basename"]) as fin:
            down = "".join(fin.readlines())
            assert.ok(down.startswith(">"))
            assert.ok(down.trim().endswith("accc"))
        os.remove(up["basename"])

        new shell(`${apollo} file download ${P} -i {up['_id']} -o tmp.fa`)
        with open("tmp.fa") as fin:
            down = "".join(fin.readlines())
            assert.ok(down.startswith(">"))
            assert.ok(down.trim().endswith("accc"))
        os.remove("tmp.fa")

        let p = new shell(`${apollo} file download ${P} -i {up['_id']} -o -`)
        assert.ok(p.stdout.startswith(">"))
        assert.ok(p.stdout.trim().endswith("accc"))
    })

    globalThis.itName('testDeleteFile', () => {
        let p = new shell(`${apollo} file upload ${P} test_data/tiny.fasta`)
        up1 = JSON.parse(p.stdout)
        let p = new shell(`${apollo} file upload ${P} test_data/tiny.fasta`)
        up2 = JSON.parse(p.stdout)

        let p = new shell(`${apollo} file delete ${P} -i {up1['_id']} {up2['_id']}`)
        out = JSON.parse(p.stdout)
        assert.strictEqual(2, out.length)

        let p = new shell(`${apollo} file get ${P} -i {up1['_id']} {up2['_id']}`)
        out = JSON.parse(p.stdout)
        assert.strictEqual(0, out.length)
